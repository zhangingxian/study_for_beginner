//欧几里德算法缺陷
//欧几里德算法是计算两个数最大公约数的传统算法，无论从理论还是从实际效率上都是很好的。但是却有一个致命的缺陷，这个缺陷在素数比较小的时候一般是感觉不到的，只有在大素数时才会显现出来。
//一般实际应用中的整数很少会超过64位（当然已经允许128位了），对于这样的整数，计算两个数之间的模是很简单的。对于字长为32位的平台，计算两个不超过32位的整数的模，只需要一个指令周期，而计算64位以下的整数模，也不过几个周期而已。但是对于更大的素数，这样的计算过程就不得不由用户来设计，为了计算两个超过64位的整数的模，用户也许不得不采用类似于多位数除法手算过程中的试商法，这个过程不但复杂，而且消耗了很多CPU时间。对于现代密码算法，要求计算128位以上的素数的情况比比皆是，设计这样的程序迫切希望能够抛弃除法和取模。
//算法步骤
//1、设置An=|A|、Bn=|B|、Cn=1和n=1
//2、如果An=Bn,那么An(或Bn)*Cn是最大公约数,算法结束
//3、如果An=0，Bn是最大公约数，算法结束
//4、如果Bn=0，An是最大公约数，算法结束
//5、如果An和Bn都是偶数，则An+1=An/2，Bn+1=Bn/2，Cn+1=Cn*2(注意，乘2只要把整数左移一位即可，除2只要把整数右移一位即可)
//6、如果An是偶数，Bn不是偶数，则An+1=An/2，Bn+1=Bn，Cn+1=Cn(很显然啦，2不是奇数的约数)
//7、如果Bn是偶数，An不是偶数，则Bn+1=Bn/2，An+1=An，Cn+1=Cn(很显然啦，2不是奇数的约数)
//8、如果An和Bn都不是偶数，则An+1=|An-Bn|
// ，Bn+1=min(An,Bn)，Cn+1=Cn
//9、n=n+1，转2
//两种算法的对比
//欧几里德算法每次迭代中最恶劣的情况是，a=2b-1，这样，迭代后，r=b-1。如果a小于2^N，这样大约需要4N次迭代。而Stein算法，每次迭代后，显然AN+1BN+1≤ ANBN/2，最大迭代次数也不超过4N次。也就是说，迭代次数几乎是相等的。但是，需要注意的是，对于大素数，试商法将使每次迭代都更复杂，因此对于大素数，Stein算法将更有优势。
// Created by  yuan on 2021/12/14.
//
#include<iostream>
using namespace std;
int gcd(int a,int b)
{
    int g;
    if(b==0)
        g=a;
    else
        g=gcd(b,a%b);
    return g;
}
int sgcd(int a, int b) {
    int t;
    if(a < b){
        t = a;
        a = b;
        b = t;
    }
    if(b == 0) return a;
    if(a % 2 == 0 && b % 2 == 0)
    {
        return 2 * sgcd(a / 2, b / 2);
    }
    else if(a % 2 == 0 && b % 2 != 0)
    {
        return sgcd(a / 2, b);
    }
    else if(a % 2 != 0 && b % 2 == 0)
    {
        return sgcd(a, b / 2);
    }
    else
    {
        return sgcd(a-b, b);
    }
}
int main()
{
  int a,b;
while(cin>>a>>b)
{
    cout<<gcd(a,b)<<endl;
    cout<<sgcd(a,b)<<endl;
}
}
